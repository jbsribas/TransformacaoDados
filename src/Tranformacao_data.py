# -*- coding: utf-8 -*-
"""Aula7_ETL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tJUbzn0T5MVgBd1IArwCUsK8j3EY0xWO
"""

### Tranformação de dados
import numpy as np
import pandas as pd
import requests
from bs4 import BeautifulSoup

dic = {'nome':['Antonio','Francisco','Patricia','Tereza'],
       'dataNascimento':['23/09/1984','17/08/1998','12/04/2014','05/05/2003'],
       'telefone':['11-2222-2222','11-3333-3333','11-2323-2323','11-5555-5555']}
sistemaA = pd.DataFrame(dic)

dic = {'nome':['Carla','Almeida','Pereira','Luiz','Bianca'],
       'dataNascimento':['2003-09-08','2001-01-17','1986-04-07', '1997-04-04','1993-06-03'],
       'telefone':['(11)2222-2222','(11)3333-3333','(11)2323-2323','(11)5555-5555','(11)5555-5555']}
sistemaB = pd.DataFrame(dic)

sistemaA

sistemaB

#dd/MM/YYYY
#MM-dd-YYYY
#dd-MM-YYYY
#YYYY-MM-dd
##YYYY-dd-MM
#YYYY/MM/dd
#YYYY/dd/MM

# qual padrão desejamos adotar!!!
###dd/MM/YYYY
def mudarData(data, padrao):
  dia = " "
  mes = " "
  ano = " "
  if padrao.upper() == 'MM/DD/YYYY':
       mes,dia,ano = data.split('/')

  elif padrao.upper() == 'MM-DD-YYYY':
    mes,dia,ano = data.split('-')

  elif padrao.upper() == 'DD-MM-YYYY':
     dia, mes,ano = data.split('-')

  elif padrao.upper() == 'YYYY-DD-MM':
    ano,dia, mes = data.split('-')

  elif padrao.upper() == 'YYYY/DD/MM':
    ano,dia, mes = data.split('/')

  elif padrao.upper() == 'YYYY-MM-DD':
    ano, mes, dia = data.split('-')
  #........ colocar de

  else:
    dia,mes,ano = 0,0,0
  return dia+'/'+mes+'/'+ano

mudarData('1988-12-11','YYYY-MM-dd')

#alteração do padrão da data
# usando a função criada
sistemaB.dataNascimento = sistemaB.dataNascimento.apply(lambda a: mudarData(a,'YYYY-MM-DD'))

display(sistemaB)

# telefone
#dd-dddd-dddd
#(dd)dddd-dddd
def alterarTelefone(telefone,padrao):
  ddd = " "
  primeiros = " "
  segundo = " "
  if padrao.upper() == 'DD-DDDD-DDDD':
    ddd,primeiros,segundo = telefone.split('-')

  else:
    ddd,primeiros,segundo = 0,0,0

  return '('+ddd+')'+primeiros+"-"+segundo

alterarTelefone('55-55555-6666','dd-dddd-dddd')

sistemaA.telefone = sistemaA.telefone.apply(lambda k: alterarTelefone(k,'dd-dddd-dddd'))

sistemaA

sistema = pd.concat([sistemaA,sistemaB])

display(sistema)

# colocar todos os nomes em maisculo
sistema['nome'] = sistema.nome.apply(lambda p: p.upper())

sistema

### tirar o dado da internet
url = 'https://www.contextures.com/xlsampledata01.html'
tbl = pd.read_html(url)
print(type(tbl))

tabela = tbl[1]

tabela
# registro 0 vire o nome das colunas
tabela.columns = tabela.iloc[0, :]
tabela.columns

# remover uma linha da tabela
tabela.drop(index=0, inplace= True)

tabela
#m/d/yyyy
# Quando o valor for menor que 10 precisa colocar o zero na frente
# 1 => 01
# 8 => 08
# isso no mes e dia

#dd/MM/ YYYY
def dataNova(data):
  m,d,a = data.split('/')
  if len(m) == 1:
    m = '0'+str(m)

  if len(d) == 1:
    d = '0'+str(d)

  return d+'/'+m+'/'+a

dataNova('6/10/2023')

tabela.OrderDate = tabela.OrderDate.apply(lambda t: dataNova(t))

tabela

amLivros = pd.read_csv("Amazon_livros.csv")

amLivros.head()

# ajustar o preço
## remover R$
# trocar , por ponto
# converter a saida disso tudo para float

preco = amLivros.preco[0]
print(preco)
preco = float(preco.replace("R$ ","").replace(",","."))

#alterado toda coluna preço

amLivros.preco = amLivros.preco.apply(lambda z: float(z.replace("R$ ","").replace(",",".")))

amLivros.dtypes

amLivros.preco.sum()

amLivros.preco.mean()

# limpar sujeira do autor
autor = amLivros.autor[0]
autor = autor.strip()

# aplicar em toda a coluna do autor
amLivros.autor = amLivros.autor.apply(lambda r: r.strip().replace('por ',"") )

amLivros.dtypes

amLivros.iloc[:, 0]

amLivros.drop(columns=['Unnamed: 0'], inplace= True)

amLivros.columns

amLivros['autor'].value_counts()

# exericio
# ajustar o preço do arquivo livro ( arquivo no google drive)
# deixar como float
# fazer o somatirui dos livros
# calcular a media e a mediana dos livros

livro = pd.read_csv("livro.csv")
livro.head()

livro.disp= livro.disp.apply(lambda d: d.strip())

livro.preco = livro.preco.apply(lambda p: float(p.replace("Â£","")))

livro.preco.median()

livro.preco.mean()

livro.preco.sum()

## alem padronizar vamos tratar valores em branco e outlier
produtos = pd.read_csv("Produtos.csv")
produtos.head()

# converti -1 em espaço em branco
produtos[produtos.preco == ' '] = 'NAN'

happy = pd.read_csv('world_happiness_report_2015.csv')

happy.isna().any()

# remoção de valores ausentes
# remover a coluna com todos os valores em branco
df1 = happy.dropna(axis = 1, how = 'all')

df1.columns

df2 = happy.dropna(axis = 1, how = 'any')

df2.columns

#linhas que estejam totalmente em branco
df3 = happy.dropna(axis = 0, how='all')

# padrão, remover linhas com campos em branco
df3 = happy.dropna(axis = 0, how = 'any')

# preencher valores ausentes
  happy['dystopia residual'].fillna(happy['dystopia residual'].median(),
                                    inplace=True)

  happy['happiness score'].fillna(happy['happiness score'].mean(),
                                  inplace = True)

  happy['standard error'].fillna(happy['standard error'].mean(),
                                inplace = True)

colunas = happy.select_dtypes(include = 'number').columns

import matplotlib.pyplot as plt

for col in colunas:
  plt.boxplot(happy[col])
  plt.title(col)
  plt.show()

# normalização por escala
dado = happy['dystopia residual']

max = dado.max()

min = dado.min()

novo_max = 1

novo_min = 0

novoDado = ((dado-min)/(max-min)) * (novo_max-novo_min)+novo_min

novoDado

# todo mundo numa mesma faixa, escala ou frequqncia ou seja normalizado

# função para normalizar os dados
def normalizar(dado):
  max = dado.max()
  min = dado.min()
  novo_max = 1
  novo_min = 0
  novoDado = ((dado-min)/(max-min)) * (novo_max-novo_min)+novo_min
  return novoDado

def normalizar2(dado, novo_max,  novo_min):
  max = dado.max()
  min = dado.min()
  novoDado = ((dado-min)/(max-min)) * (novo_max-novo_min)+novo_min
  return novoDado

x = normalizar(happy.generosity)

#Dados categoricos

#dados Categoricos
tabela

tabela.Region.value_counts()

cat = {"Region":{"Central":1,
                 "East":2,
                 "West":3}}

tbl_cat = tabela.replace(cat)

#conversão de object para category
# funçãp astype faz a conversão de tipos de dados da coluna todinha
tabela.Region = tabela.Region.astype('category')

display(tabela)

tabela.dtypes

tabela.Region.cat.codes

tabela.to_csv("tabela.csv", index=False)

# nos campos do df Tabela
# verificar se a coluna Rep tem valores repetidos
# se sim converter a coluna para dado categorico
# verificar se a coluna Itemm possuem valores repetidos
# se tiver converter essa coluna para dado categorico
#listar as categorias de ambas as colunas
# converter pata float o preço unitario e preço total
# converter para inteiro a coluna unidades]
# converter para data a coluna orderDate
### Ver documentação biblioteca DataTime